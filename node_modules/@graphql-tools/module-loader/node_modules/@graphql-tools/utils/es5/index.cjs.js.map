{"version":3,"file":"index.cjs.js","sources":["../../../dist-es5/utils/src/helpers.js","../../../dist-es5/utils/src/debug-log.js","../../../dist-es5/utils/src/fix-windows-path.js","../../../dist-es5/utils/src/flatten-array.js","../../../dist-es5/utils/src/inspect.js","../../../dist-es5/utils/src/getArgumentValues.js","../../../dist-es5/utils/src/get-directives.js","../../../dist-es5/utils/src/get-fields-with-directives.js","../../../dist-es5/utils/src/get-implementing-types.js","../../../dist-es5/utils/src/astFromType.js","../../../dist-es5/utils/src/astFromValueUntyped.js","../../../dist-es5/utils/src/print-schema-with-directives.js","../../../dist-es5/utils/src/validate-documents.js","../../../dist-es5/utils/src/fix-schema-ast.js","../../../node_modules/graphql/language/blockString.mjs","../../../dist-es5/utils/src/parse-graphql-sdl.js","../../../dist-es5/utils/src/parse-graphql-json.js","../../../dist-es5/utils/src/get-user-types-from-schema.js","../../../dist-es5/utils/src/create-schema-definition.js","../../../dist-es5/utils/src/build-operation-for-field.js","../../../dist-es5/utils/src/Interfaces.js","../../../dist-es5/utils/src/stub.js","../../../dist-es5/utils/src/rewire.js","../../../dist-es5/utils/src/transformInputValue.js","../../../dist-es5/utils/src/mapSchema.js","../../../dist-es5/utils/src/filterSchema.js","../../../dist-es5/utils/src/clone.js","../../../dist-es5/utils/src/heal.js","../../../dist-es5/utils/src/SchemaVisitor.js","../../../dist-es5/utils/src/visitSchema.js","../../../dist-es5/utils/src/SchemaDirectiveVisitor.js","../../../dist-es5/utils/src/getResolversFromSchema.js","../../../dist-es5/utils/src/forEachField.js","../../../dist-es5/utils/src/forEachDefaultValue.js","../../../dist-es5/utils/src/addTypes.js","../../../dist-es5/utils/src/prune.js","../../../dist-es5/utils/src/mergeDeep.js","../../../dist-es5/utils/src/selectionSets.js","../../../dist-es5/utils/src/getResponseKeyFromInfo.js","../../../dist-es5/utils/src/fields.js","../../../dist-es5/utils/src/renameType.js","../../../dist-es5/utils/src/collectFields.js","../../../dist-es5/utils/src/mapAsyncIterator.js","../../../dist-es5/utils/src/updateArgument.js","../../../dist-es5/utils/src/implementsAbstractType.js","../../../dist-es5/utils/src/errors.js","../../../dist-es5/utils/src/toConfig.js","../../../dist-es5/utils/src/observableToAsyncIterable.js","../../../dist-es5/utils/src/visitResult.js","../../../dist-es5/utils/src/valueMatchesCriteria.js","../../../dist-es5/utils/src/isAsyncIterable.js","../../../dist-es5/utils/src/isDocumentNode.js","../../../dist-es5/utils/src/withCancel.js"],"sourcesContent":["import { parse } from 'graphql';\nexport var asArray = function (fns) { return (Array.isArray(fns) ? fns : fns ? [fns] : []); };\nexport function isEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var index = 0; index < a.length; index++) {\n            if (a[index] !== b[index]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b || (!a && !b);\n}\nexport function isNotEqual(a, b) {\n    return !isEqual(a, b);\n}\nexport function isDocumentString(str) {\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (/\\.[a-z0-9]+$/i.test(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nvar invalidPathRegex = /[‘“!%&^<=>`]/;\nexport function isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexport function compareStrings(a, b) {\n    if (a.toString() < b.toString()) {\n        return -1;\n    }\n    if (a.toString() > b.toString()) {\n        return 1;\n    }\n    return 0;\n}\nexport function nodeToString(a) {\n    if ('alias' in a) {\n        return a.alias.value;\n    }\n    if ('name' in a) {\n        return a.name.value;\n    }\n    return a.kind;\n}\nexport function compareNodes(a, b, customFn) {\n    var aStr = nodeToString(a);\n    var bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\n//# sourceMappingURL=helpers.js.map","import { __read, __spreadArray } from \"tslib\";\nexport function debugLog() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (process && process.env && process.env.DEBUG && !process.env.GQL_tools_NODEBUG) {\n        // tslint:disable-next-line: no-console\n        console.log.apply(console, __spreadArray([], __read(args)));\n    }\n}\n//# sourceMappingURL=debug-log.js.map","export var fixWindowsPath = function (path) { return path.replace(/\\\\/g, '/'); };\n//# sourceMappingURL=fix-windows-path.js.map","export var flattenArray = function (arr) {\n    return arr.reduce(function (acc, next) { return acc.concat(Array.isArray(next) ? flattenArray(next) : next); }, []);\n};\n//# sourceMappingURL=flatten-array.js.map","import { __read, __spreadArray } from \"tslib\";\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? \"[function \" + value.name + \"]\" : '[function]';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (previouslySeenValues.indexOf(value) !== -1) {\n        return '[Circular]';\n    }\n    var seenValues = __spreadArray(__spreadArray([], __read(previouslySeenValues)), [value]);\n    var customInspectFn = getCustomFn(value);\n    if (customInspectFn !== undefined) {\n        var customValue = customInspectFn.call(value);\n        // check for infinite recursion\n        if (customValue !== value) {\n            return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction formatObject(object, seenValues) {\n    var keys = Object.keys(object);\n    if (keys.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    var properties = keys.map(function (key) {\n        var value = formatValue(object[key], seenValues);\n        return key + ': ' + value;\n    });\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    var remaining = array.length - len;\n    var items = [];\n    for (var i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(\"... \" + remaining.toString(10) + \" more items\");\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getCustomFn(obj) {\n    if (typeof obj.inspect === 'function') {\n        return obj.inspect;\n    }\n}\nfunction getObjectTag(obj) {\n    var tag = Object.prototype.toString\n        .call(obj)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof obj.constructor === 'function') {\n        var name_1 = obj.constructor.name;\n        if (typeof name_1 === 'string' && name_1 !== '') {\n            return name_1;\n        }\n    }\n    return tag;\n}\n//# sourceMappingURL=inspect.js.map","import { __assign, __read, __values } from \"tslib\";\nimport { valueFromAST, isNonNullType, GraphQLError, Kind, print, } from 'graphql';\nimport { inspect } from './inspect';\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues) {\n    var e_1, _a;\n    var _b;\n    if (variableValues === void 0) { variableValues = {}; }\n    var variableMap = Object.entries(variableValues).reduce(function (prev, _a) {\n        var _b;\n        var _c = __read(_a, 2), key = _c[0], value = _c[1];\n        return (__assign(__assign({}, prev), (_b = {}, _b[key] = value, _b)));\n    }, {});\n    var coercedValues = {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    var argumentNodes = (_b = node.arguments) !== null && _b !== void 0 ? _b : [];\n    var argNodeMap = argumentNodes.reduce(function (prev, arg) {\n        var _a;\n        return (__assign(__assign({}, prev), (_a = {}, _a[arg.name.value] = arg, _a)));\n    }, {});\n    try {\n        for (var _c = __values(def.args), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var argDef = _d.value;\n            var name_1 = argDef.name;\n            var argType = argDef.type;\n            var argumentNode = argNodeMap[name_1];\n            if (!argumentNode) {\n                if (argDef.defaultValue !== undefined) {\n                    coercedValues[name_1] = argDef.defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" + 'was not provided.', node);\n                }\n                continue;\n            }\n            var valueNode = argumentNode.value;\n            var isNull = valueNode.kind === Kind.NULL;\n            if (valueNode.kind === Kind.VARIABLE) {\n                var variableName = valueNode.name.value;\n                if (variableValues == null || !(variableName in variableMap)) {\n                    if (argDef.defaultValue !== undefined) {\n                        coercedValues[name_1] = argDef.defaultValue;\n                    }\n                    else if (isNonNullType(argType)) {\n                        throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\n                            (\"was provided the variable \\\"$\" + variableName + \"\\\" which was not provided a runtime value.\"), valueNode);\n                    }\n                    continue;\n                }\n                isNull = variableValues[variableName] == null;\n            }\n            if (isNull && isNonNullType(argType)) {\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of non-null type \\\"\" + inspect(argType) + \"\\\" \" + 'must not be null.', valueNode);\n            }\n            var coercedValue = valueFromAST(valueNode, argType, variableValues);\n            if (coercedValue === undefined) {\n                // Note: ValuesOfCorrectTypeRule validation should catch this before\n                // execution. This is a runtime check to ensure execution does not\n                // continue with an invalid argument value.\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" has invalid value \" + print(valueNode) + \".\", valueNode);\n            }\n            coercedValues[name_1] = coercedValue;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return coercedValues;\n}\n//# sourceMappingURL=getArgumentValues.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { getArgumentValues } from './getArgumentValues';\nexport function getDirectivesInExtensions(node, pathToDirectivesInExtensions) {\n    if (pathToDirectivesInExtensions === void 0) { pathToDirectivesInExtensions = ['directives']; }\n    var directivesInExtensions = pathToDirectivesInExtensions.reduce(function (acc, pathSegment) { return (acc == null ? acc : acc[pathSegment]); }, node === null || node === void 0 ? void 0 : node.extensions);\n    return directivesInExtensions;\n}\nexport function getDirectives(schema, node, pathToDirectivesInExtensions) {\n    if (pathToDirectivesInExtensions === void 0) { pathToDirectivesInExtensions = ['directives']; }\n    var directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n    if (directivesInExtensions != null) {\n        return directivesInExtensions;\n    }\n    var schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    var schemaDirectiveMap = schemaDirectives.reduce(function (schemaDirectiveMap, schemaDirective) {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    var astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = __spreadArray(__spreadArray([], __read(astNodes)), __read(node.extensionASTNodes));\n    }\n    var result = {};\n    astNodes.forEach(function (astNode) {\n        if (astNode.directives) {\n            astNode.directives.forEach(function (directiveNode) {\n                var _a;\n                var schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n                if (schemaDirective) {\n                    if (schemaDirective.isRepeatable) {\n                        result[schemaDirective.name] = (_a = result[schemaDirective.name]) !== null && _a !== void 0 ? _a : [];\n                        result[schemaDirective.name].push(getArgumentValues(schemaDirective, directiveNode));\n                    }\n                    else {\n                        result[schemaDirective.name] = getArgumentValues(schemaDirective, directiveNode);\n                    }\n                }\n            });\n        }\n    });\n    return result;\n}\n//# sourceMappingURL=get-directives.js.map","import { __assign, __read, __spreadArray, __values } from \"tslib\";\nimport { Kind, } from 'graphql';\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case Kind.INT:\n            return parseInt(value.value);\n        case Kind.FLOAT:\n            return parseFloat(value.value);\n        case Kind.BOOLEAN:\n            return Boolean(value.value);\n        case Kind.STRING:\n        case Kind.ENUM:\n            return value.value;\n        case Kind.LIST:\n            return value.values.map(function (v) { return parseDirectiveValue(v); });\n        case Kind.OBJECT:\n            return value.fields.reduce(function (prev, v) {\n                var _a;\n                return (__assign(__assign({}, prev), (_a = {}, _a[v.name.value] = parseDirectiveValue(v.value), _a)));\n            }, {});\n        case Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nexport function getFieldsWithDirectives(documentNode, options) {\n    var e_1, _a, e_2, _b;\n    if (options === void 0) { options = {}; }\n    var result = {};\n    var selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = __spreadArray(__spreadArray([], __read(selected)), ['InputObjectTypeDefinition', 'InputObjectTypeExtension']);\n    }\n    var allTypes = documentNode.definitions.filter(function (obj) { return selected.includes(obj.kind); });\n    try {\n        for (var allTypes_1 = __values(allTypes), allTypes_1_1 = allTypes_1.next(); !allTypes_1_1.done; allTypes_1_1 = allTypes_1.next()) {\n            var type = allTypes_1_1.value;\n            var typeName = type.name.value;\n            try {\n                for (var _c = (e_2 = void 0, __values(type.fields)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var field = _d.value;\n                    if (field.directives && field.directives.length > 0) {\n                        var fieldName = field.name.value;\n                        var key = typeName + \".\" + fieldName;\n                        var directives = field.directives.map(function (d) { return ({\n                            name: d.name.value,\n                            args: (d.arguments || []).reduce(function (prev, arg) {\n                                var _a;\n                                return (__assign(__assign({}, prev), (_a = {}, _a[arg.name.value] = parseDirectiveValue(arg.value), _a)));\n                            }, {}),\n                        }); });\n                        result[key] = directives;\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (allTypes_1_1 && !allTypes_1_1.done && (_a = allTypes_1.return)) _a.call(allTypes_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return result;\n}\n//# sourceMappingURL=get-fields-with-directives.js.map","import { isObjectType } from 'graphql';\nexport function getImplementingTypes(interfaceName, schema) {\n    var allTypesMap = schema.getTypeMap();\n    var result = [];\n    for (var graphqlTypeName in allTypesMap) {\n        var graphqlType = allTypesMap[graphqlTypeName];\n        if (isObjectType(graphqlType)) {\n            var allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(function (int) { return int.name === interfaceName; })) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=get-implementing-types.js.map","import { isNonNullType, Kind, isListType } from 'graphql';\nexport function astFromType(type) {\n    if (isNonNullType(type)) {\n        var innerType = astFromType(type.ofType);\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\n            throw new Error(\"Invalid type node \" + JSON.stringify(type) + \". Inner type of non-null type cannot be a non-null type.\");\n        }\n        return {\n            kind: Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (isListType(type)) {\n        return {\n            kind: Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: Kind.NAMED_TYPE,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n//# sourceMappingURL=astFromType.js.map","import { __read } from \"tslib\";\nimport { Kind } from 'graphql';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\nexport function astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        var valuesNodes_1 = [];\n        value.forEach(function (item) {\n            var itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes_1.push(itemNode);\n            }\n        });\n        return { kind: Kind.LIST, values: valuesNodes_1 };\n    }\n    if (typeof value === 'object') {\n        var fieldNodes_1 = [];\n        Object.entries(value).forEach(function (_a) {\n            var _b = __read(_a, 2), fieldName = _b[0], fieldValue = _b[1];\n            var ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes_1.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        });\n        return { kind: Kind.OBJECT, fields: fieldNodes_1 };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: Kind.BOOLEAN, value: value };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        var stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: Kind.INT, value: stringNum }\n            : { kind: Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: Kind.STRING, value: value };\n    }\n    throw new TypeError(\"Cannot convert value to AST: \" + value + \".\");\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n//# sourceMappingURL=astFromValueUntyped.js.map","import { __read, __spreadArray, __values } from \"tslib\";\nimport { print, Kind, isSpecifiedScalarType, isIntrospectionType, isSpecifiedDirective, astFromValue, GraphQLDeprecatedDirective, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isEnumType, isScalarType, } from 'graphql';\nimport { astFromType } from './astFromType';\nimport { getDirectivesInExtensions } from './get-directives';\nimport { astFromValueUntyped } from './astFromValueUntyped';\nexport function getDocumentNodeFromSchema(schema, options) {\n    var e_1, _a;\n    if (options === void 0) { options = {}; }\n    var pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    var typesMap = schema.getTypeMap();\n    var schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    var definitions = schemaNode != null ? [schemaNode] : [];\n    var directives = schema.getDirectives();\n    try {\n        for (var directives_1 = __values(directives), directives_1_1 = directives_1.next(); !directives_1_1.done; directives_1_1 = directives_1.next()) {\n            var directive = directives_1_1.value;\n            if (isSpecifiedDirective(directive)) {\n                continue;\n            }\n            definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (directives_1_1 && !directives_1_1.done && (_a = directives_1.return)) _a.call(directives_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    for (var typeName in typesMap) {\n        var type = typesMap[typeName];\n        var isPredefinedScalar = isSpecifiedScalarType(type);\n        var isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(\"Unknown type \" + type + \".\");\n        }\n    }\n    return {\n        kind: Kind.DOCUMENT,\n        definitions: definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nexport function printSchemaWithDirectives(schema, options) {\n    if (options === void 0) { options = {}; }\n    var documentNode = getDocumentNodeFromSchema(schema, options);\n    return print(documentNode);\n}\nexport function astFromSchema(schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    var operationTypeMap = {\n        query: undefined,\n        mutation: undefined,\n        subscription: undefined,\n    };\n    var nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        nodes = nodes.concat(schema.extensionASTNodes);\n    }\n    nodes.forEach(function (node) {\n        if (node.operationTypes) {\n            node.operationTypes.forEach(function (operationTypeDefinitionNode) {\n                operationTypeMap[operationTypeDefinitionNode.operation] = operationTypeDefinitionNode;\n            });\n        }\n    });\n    var rootTypeMap = {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n    };\n    Object.keys(operationTypeMap).forEach(function (operationTypeNode) {\n        if (rootTypeMap[operationTypeNode] != null) {\n            if (operationTypeMap[operationTypeNode] != null) {\n                operationTypeMap[operationTypeNode].type = astFromType(rootTypeMap[operationTypeNode]);\n            }\n            else {\n                operationTypeMap[operationTypeNode] = {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: astFromType(rootTypeMap[operationTypeNode]),\n                };\n            }\n        }\n    });\n    var operationTypes = Object.values(operationTypeMap).filter(function (operationTypeDefinitionNode) { return operationTypeDefinitionNode != null; });\n    var directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    var schemaNode = {\n        kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n        operationTypes: operationTypes,\n        directives: directives,\n    };\n    schemaNode.description =\n        ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null)\n            ? {\n                kind: Kind.STRING,\n                value: schema.description,\n                block: true,\n            }\n            : undefined;\n    return schemaNode;\n}\nexport function astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (directive.description\n            ? {\n                kind: Kind.STRING,\n                value: directive.description,\n            }\n            : undefined),\n        name: {\n            kind: Kind.NAME,\n            value: directive.name,\n        },\n        arguments: (directive === null || directive === void 0 ? void 0 : directive.args)\n            ? directive.args.map(function (arg) { return astFromArg(arg, schema, pathToDirectivesInExtensions); })\n            : undefined,\n        repeatable: directive.isRepeatable,\n        locations: (directive === null || directive === void 0 ? void 0 : directive.locations)\n            ? directive.locations.map(function (location) { return ({\n                kind: Kind.NAME,\n                value: location,\n            }); })\n            : undefined,\n    };\n}\nexport function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    var directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    var nodes = [];\n    if (entity.astNode != null) {\n        nodes.push(entity.astNode);\n    }\n    if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n        nodes = nodes.concat(entity.extensionASTNodes);\n    }\n    var directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = [].concat.apply([], __spreadArray([], __read(nodes.filter(function (node) { return node.directives != null; }).map(function (node) { return node.directives; }))));\n    }\n    return directives;\n}\nexport function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    var directiveNodesBesidesDeprecated = [];\n    var deprecatedDirectiveNode;\n    var directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    var directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n    }\n    if (directives != null) {\n        directiveNodesBesidesDeprecated = directives.filter(function (directive) { return directive.name.value !== 'deprecated'; });\n        if (entity.deprecationReason != null) {\n            deprecatedDirectiveNode = (_b = directives.filter(function (directive) { return directive.name.value === 'deprecated'; })) === null || _b === void 0 ? void 0 : _b[0];\n        }\n    }\n    if (entity.deprecationReason != null &&\n        deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    return deprecatedDirectiveNode == null\n        ? directiveNodesBesidesDeprecated\n        : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\nexport function astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: ((_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description)\n            ? {\n                kind: Kind.STRING,\n                value: arg.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        defaultValue: arg.defaultValue !== undefined ? astFromValue(arg.defaultValue, arg.type) : undefined,\n        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: ((_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(function (field) { return astFromField(field, schema, pathToDirectivesInExtensions); }),\n        interfaces: Object.values(type.getInterfaces()).map(function (iFace) { return astFromType(iFace); }),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    var node = {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: ((_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(function (field) { return astFromField(field, schema, pathToDirectivesInExtensions); }),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(function (iFace) { return astFromType(iFace); });\n    }\n    return node;\n}\nexport function astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: ((_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(function (type) { return astFromType(type); }),\n    };\n}\nexport function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: ((_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(function (field) {\n            return astFromInputField(field, schema, pathToDirectivesInExtensions);\n        }),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: ((_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(function (value) { return astFromEnumValue(value, schema, pathToDirectivesInExtensions); }),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c, _d;\n    var directiveNodesBesidesSpecifiedBy = [];\n    var specifiedByDirectiveNode;\n    var directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    var allDirectives;\n    if (directivesInExtensions != null) {\n        allDirectives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        allDirectives = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n    }\n    if (allDirectives != null) {\n        directiveNodesBesidesSpecifiedBy = allDirectives.filter(function (directive) { return directive.name.value !== 'specifiedBy'; });\n        if (type.specifiedByUrl != null) {\n            specifiedByDirectiveNode = (_b = allDirectives.filter(function (directive) { return directive.name.value === 'specifiedBy'; })) === null || _b === void 0 ? void 0 : _b[0];\n        }\n    }\n    if (type.specifiedByUrl != null && specifiedByDirectiveNode == null) {\n        specifiedByDirectiveNode = makeDirectiveNode('specifiedBy', {\n            url: type.specifiedByUrl,\n        });\n    }\n    var directives = specifiedByDirectiveNode == null\n        ? directiveNodesBesidesSpecifiedBy\n        : [specifiedByDirectiveNode].concat(directiveNodesBesidesSpecifiedBy);\n    return {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: ((_d = (_c = type.astNode) === null || _c === void 0 ? void 0 : _c.description) !== null && _d !== void 0 ? _d : type.description)\n            ? {\n                kind: Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        directives: directives,\n    };\n}\nexport function astFromField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.FIELD_DEFINITION,\n        description: ((_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description)\n            ? {\n                kind: Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(function (arg) { return astFromArg(arg, schema, pathToDirectivesInExtensions); }),\n        type: astFromType(field.type),\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: ((_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description)\n            ? {\n                kind: Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: astFromValue(field.defaultValue, field.type),\n    };\n}\nexport function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: ((_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description)\n            ? {\n                kind: Kind.STRING,\n                value: value.description,\n                block: true,\n            }\n            : undefined,\n        name: {\n            kind: Kind.NAME,\n            value: value.name,\n        },\n        directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, GraphQLDeprecatedDirective);\n}\nexport function makeDirectiveNode(name, args, directive) {\n    var directiveArguments = [];\n    if (directive != null) {\n        directive.args.forEach(function (arg) {\n            var argName = arg.name;\n            var argValue = args[argName];\n            if (argValue !== undefined) {\n                directiveArguments.push({\n                    kind: Kind.ARGUMENT,\n                    name: {\n                        kind: Kind.NAME,\n                        value: argName,\n                    },\n                    value: astFromValue(argValue, arg.type),\n                });\n            }\n        });\n    }\n    else {\n        Object.entries(args).forEach(function (_a) {\n            var _b = __read(_a, 2), argName = _b[0], argValue = _b[1];\n            directiveArguments.push({\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: argName,\n                },\n                value: astFromValueUntyped(argValue),\n            });\n        });\n    }\n    return {\n        kind: Kind.DIRECTIVE,\n        name: {\n            kind: Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nexport function makeDirectiveNodes(schema, directiveValues) {\n    var directiveNodes = [];\n    Object.entries(directiveValues).forEach(function (_a) {\n        var _b = __read(_a, 2), directiveName = _b[0], arrayOrSingleValue = _b[1];\n        var directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n        if (Array.isArray(arrayOrSingleValue)) {\n            arrayOrSingleValue.forEach(function (value) {\n                directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n            });\n        }\n        else {\n            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n        }\n    });\n    return directiveNodes;\n}\n//# sourceMappingURL=print-schema-with-directives.js.map","import { __awaiter, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { Kind, validate, specifiedRules, } from 'graphql';\nimport AggregateError from '@ardatan/aggregate-error';\nexport function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {\n    return __awaiter(this, void 0, void 0, function () {\n        var allFragments, allErrors;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    effectiveRules = effectiveRules || createDefaultRules();\n                    allFragments = [];\n                    documentFiles.forEach(function (documentFile) {\n                        var e_1, _a;\n                        if (documentFile.document) {\n                            try {\n                                for (var _b = __values(documentFile.document.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {\n                                    var definitionNode = _c.value;\n                                    if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n                                        allFragments.push(definitionNode);\n                                    }\n                                }\n                            }\n                            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                            finally {\n                                try {\n                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                                }\n                                finally { if (e_1) throw e_1.error; }\n                            }\n                        }\n                    });\n                    allErrors = [];\n                    return [4 /*yield*/, Promise.all(documentFiles.map(function (documentFile) { return __awaiter(_this, void 0, void 0, function () {\n                            var documentToValidate, errors;\n                            return __generator(this, function (_a) {\n                                documentToValidate = {\n                                    kind: Kind.DOCUMENT,\n                                    definitions: __spreadArray(__spreadArray([], __read(allFragments)), __read(documentFile.document.definitions)).filter(function (definition, index, list) {\n                                        if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n                                            var firstIndex = list.findIndex(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION && def.name.value === definition.name.value; });\n                                            var isDuplicated = firstIndex !== index;\n                                            if (isDuplicated) {\n                                                return false;\n                                            }\n                                        }\n                                        return true;\n                                    }),\n                                };\n                                errors = validate(schema, documentToValidate, effectiveRules);\n                                if (errors.length > 0) {\n                                    allErrors.push({\n                                        filePath: documentFile.location,\n                                        errors: errors,\n                                    });\n                                }\n                                return [2 /*return*/];\n                            });\n                        }); }))];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, allErrors];\n            }\n        });\n    });\n}\nexport function checkValidationErrors(loadDocumentErrors) {\n    var e_2, _a;\n    if (loadDocumentErrors.length > 0) {\n        var errors = [];\n        var _loop_1 = function (loadDocumentError) {\n            var e_3, _b;\n            var _loop_2 = function (graphQLError) {\n                var error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = error.name + \": \" + graphQLError.message;\n                error.stack = error.message;\n                graphQLError.locations.forEach(function (location) { return (error.stack += \"\\n    at \" + loadDocumentError.filePath + \":\" + location.line + \":\" + location.column); });\n                errors.push(error);\n            };\n            try {\n                for (var _c = (e_3 = void 0, __values(loadDocumentError.errors)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var graphQLError = _d.value;\n                    _loop_2(graphQLError);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        };\n        try {\n            for (var loadDocumentErrors_1 = __values(loadDocumentErrors), loadDocumentErrors_1_1 = loadDocumentErrors_1.next(); !loadDocumentErrors_1_1.done; loadDocumentErrors_1_1 = loadDocumentErrors_1.next()) {\n                var loadDocumentError = loadDocumentErrors_1_1.value;\n                _loop_1(loadDocumentError);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (loadDocumentErrors_1_1 && !loadDocumentErrors_1_1.done && (_a = loadDocumentErrors_1.return)) _a.call(loadDocumentErrors_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        throw new AggregateError(errors);\n    }\n}\nfunction createDefaultRules() {\n    var ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    // GraphQL v14 has no Rule suffix in function names\n    // Adding `*Rule` makes validation backwards compatible\n    ignored.forEach(function (rule) {\n        ignored.push(rule.replace(/Rule$/, ''));\n    });\n    return specifiedRules.filter(function (f) { return !ignored.includes(f.name); });\n}\n//# sourceMappingURL=validate-documents.js.map","import { __assign } from \"tslib\";\nimport { buildSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nfunction buildFixedSchema(schema, options) {\n    return buildSchema(printSchemaWithDirectives(schema), __assign({ noLocation: true }, (options || {})));\n}\nexport function fixSchemaAst(schema, options) {\n    var schemaWithValidAst;\n    if (!schema.astNode || !schema.extensionASTNodes) {\n        schemaWithValidAst = buildFixedSchema(schema, options);\n    }\n    if (!schema.astNode) {\n        schema.astNode = schemaWithValidAst.astNode;\n    }\n    if (!schema.extensionASTNodes) {\n        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n    }\n    return schema;\n}\n//# sourceMappingURL=fix-schema-ast.js.map","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(rawString);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  var startLine = 0;\n\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n\n  var endLine = lines.length;\n\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\n\nfunction isBlank(str) {\n  for (var i = 0; i < str.length; ++i) {\n    if (str[i] !== ' ' && str[i] !== '\\t') {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @internal\n */\n\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n\n  var isFirstLine = true;\n  var isEmptyLine = true;\n  var indent = 0;\n  var commonIndent = null;\n\n  for (var i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n\n      default:\n        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {\n          commonIndent = indent;\n        }\n\n        isEmptyLine = false;\n    }\n  }\n\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var hasTrailingSlash = value[value.length - 1] === '\\\\';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","import { __assign } from \"tslib\";\nimport { Kind, TokenKind, parse, Source as GraphQLSource, visit, isTypeSystemDefinitionNode, print, } from 'graphql';\nimport { dedentBlockStringValue } from 'graphql/language/blockString';\nexport function parseGraphQLSDL(location, rawSDL, options) {\n    if (options === void 0) { options = {}; }\n    var document;\n    var sdl = rawSDL;\n    var sdlModified = false;\n    try {\n        if (options.commentDescriptions && sdl.includes('#')) {\n            sdlModified = true;\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = parse(print(document), options);\n            }\n        }\n        else {\n            document = parse(new GraphQLSource(sdl, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF') && sdl.replace(/(\\#[^*]*)/g, '').trim() === '') {\n            document = {\n                kind: Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location: location,\n        document: document,\n        rawSDL: sdlModified ? print(document) : sdl,\n    };\n}\nexport function getLeadingCommentBlock(node) {\n    var loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    var comments = [];\n    var token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next &&\n        token.prev &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        var value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexport function transformCommentsToDescriptions(sourceSdl, options) {\n    if (options === void 0) { options = {}; }\n    var parsedDoc = parse(sourceSdl, __assign(__assign({}, options), { noLocation: false }));\n    var modifiedDoc = visit(parsedDoc, {\n        leave: function (node) {\n            if (isDescribable(node)) {\n                var rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    var commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    var isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return __assign(__assign({}, node), { description: {\n                                kind: Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            } });\n                    }\n                    else {\n                        return __assign(__assign({}, node), { description: __assign(__assign({}, node.description), { value: node.description.value + '\\n' + commentsBlock, block: true }) });\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nexport function isDescribable(node) {\n    return (isTypeSystemDefinitionNode(node) ||\n        node.kind === Kind.FIELD_DEFINITION ||\n        node.kind === Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === Kind.ENUM_VALUE_DEFINITION);\n}\n//# sourceMappingURL=parse-graphql-sdl.js.map","import { buildClientSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nimport { parseGraphQLSDL } from './parse-graphql-sdl';\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nexport function parseGraphQLJSON(location, jsonContent, options) {\n    var parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        var document_1 = parsedJson;\n        return {\n            location: location,\n            document: document_1,\n        };\n    }\n    else if (parsedJson.__schema) {\n        var schema = buildClientSchema(parsedJson, options);\n        var rawSDL = printSchemaWithDirectives(schema, options);\n        return {\n            location: location,\n            document: parseGraphQLSDL(location, rawSDL, options).document,\n            rawSDL: rawSDL,\n            schema: schema,\n        };\n    }\n    throw new Error(\"Not valid JSON content\");\n}\n//# sourceMappingURL=parse-graphql-json.js.map","import { isObjectType } from 'graphql';\n/**\n * Get all GraphQL types from schema without:\n *\n * - Query, Mutation, Subscription objects\n * - Internal scalars added by parser\n *\n * @param schema\n */\nexport function getUserTypesFromSchema(schema) {\n    var allTypesMap = schema.getTypeMap();\n    // tslint:disable-next-line: no-unnecessary-local-variable\n    var modelTypes = Object.values(allTypesMap).filter(function (graphqlType) {\n        if (isObjectType(graphqlType)) {\n            // Filter out private types\n            if (graphqlType.name.startsWith('__')) {\n                return false;\n            }\n            if (schema.getMutationType() && graphqlType.name === schema.getMutationType().name) {\n                return false;\n            }\n            if (schema.getQueryType() && graphqlType.name === schema.getQueryType().name) {\n                return false;\n            }\n            if (schema.getSubscriptionType() && graphqlType.name === schema.getSubscriptionType().name) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    });\n    return modelTypes;\n}\n//# sourceMappingURL=get-user-types-from-schema.js.map","export function createSchemaDefinition(def, config) {\n    var schemaRoot = {};\n    if (def.query) {\n        schemaRoot.query = def.query.toString();\n    }\n    if (def.mutation) {\n        schemaRoot.mutation = def.mutation.toString();\n    }\n    if (def.subscription) {\n        schemaRoot.subscription = def.subscription.toString();\n    }\n    var fields = Object.keys(schemaRoot)\n        .map(function (rootType) { return (schemaRoot[rootType] ? rootType + \": \" + schemaRoot[rootType] : null); })\n        .filter(function (a) { return a; });\n    if (fields.length) {\n        return \"schema { \" + fields.join('\\n') + \" }\";\n    }\n    if (config && config.force) {\n        return \" schema { query: Query } \";\n    }\n    return undefined;\n}\n//# sourceMappingURL=create-schema-definition.js.map","import { __assign, __read, __spreadArray } from \"tslib\";\nimport { isObjectType, getNamedType, isUnionType, isNonNullType, isScalarType, isListType, isInterfaceType, isEnumType, Kind, } from 'graphql';\nimport { camelCase } from 'camel-case';\nvar operationVariables = [];\nvar fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationName(name) {\n    return camelCase(name);\n}\nexport function buildOperationNodeForField(_a) {\n    var schema = _a.schema, kind = _a.kind, field = _a.field, models = _a.models, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, argNames = _a.argNames, _b = _a.selectedFields, selectedFields = _b === void 0 ? true : _b;\n    resetOperationVariables();\n    resetFieldMap();\n    var operationNode = buildOperationAndCollectVariables({\n        schema: schema,\n        fieldName: field,\n        kind: kind,\n        models: models || [],\n        ignore: ignore || [],\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames: argNames,\n        selectedFields: selectedFields,\n    });\n    // attach variables\n    operationNode.variableDefinitions = __spreadArray([], __read(operationVariables));\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables(_a) {\n    var schema = _a.schema, fieldName = _a.fieldName, kind = _a.kind, models = _a.models, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    var typeMap = {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n    };\n    var type = typeMap[kind];\n    var field = type.getFields()[fieldName];\n    var operationName = buildOperationName(fieldName + \"_\" + kind);\n    if (field.args) {\n        field.args.forEach(function (arg) {\n            var argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        });\n    }\n    return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: 'Name',\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type: type,\n                    field: field,\n                    models: models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore: ignore,\n                    depthLimit: depthLimit,\n                    circularReferenceDepth: circularReferenceDepth,\n                    schema: schema,\n                    depth: 0,\n                    argNames: argNames,\n                    selectedFields: selectedFields,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet(_a) {\n    var parent = _a.parent, type = _a.type, models = _a.models, firstCall = _a.firstCall, path = _a.path, ancestors = _a.ancestors, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, schema = _a.schema, depth = _a.depth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (isUnionType(type)) {\n        var types = type.getTypes();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(function (t) {\n                return !hasCircularRef(__spreadArray(__spreadArray([], __read(ancestors)), [t]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (t) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models: models,\n                        path: path,\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedFields,\n                    }),\n                };\n            })\n                .filter(function (fragmentNode) { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isInterfaceType(type)) {\n        var types = Object.values(schema.getTypeMap()).filter(function (t) { return isObjectType(t) && t.getInterfaces().includes(type); });\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(function (t) {\n                return !hasCircularRef(__spreadArray(__spreadArray([], __read(ancestors)), [t]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (t) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models: models,\n                        path: path,\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedFields,\n                    }),\n                };\n            })\n                .filter(function (fragmentNode) { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isObjectType(type)) {\n        var isIgnored = ignore.includes(type.name) || ignore.includes(parent.name + \".\" + path[path.length - 1]);\n        var isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: Kind.FIELD,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        var fields_1 = type.getFields();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: Object.keys(fields_1)\n                .filter(function (fieldName) {\n                return !hasCircularRef(__spreadArray(__spreadArray([], __read(ancestors)), [getNamedType(fields_1[fieldName].type)]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (fieldName) {\n                var selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields_1[fieldName],\n                        models: models,\n                        path: __spreadArray(__spreadArray([], __read(path)), [fieldName]),\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedSubFields,\n                    });\n                }\n                return null;\n            })\n                .filter(function (f) {\n                var _a, _b;\n                if (f) {\n                    if ('selectionSet' in f) {\n                        return (_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                return false;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (isListType(type)) {\n            return {\n                kind: Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (isNonNullType(type)) {\n            return {\n                kind: Kind.NON_NULL_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: Kind.NAMED_TYPE,\n            name: {\n                kind: Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return camelCase(__spreadArray(__spreadArray([], __read(path)), [name]).join('_'));\n}\nfunction resolveField(_a) {\n    var type = _a.type, field = _a.field, models = _a.models, firstCall = _a.firstCall, path = _a.path, ancestors = _a.ancestors, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, schema = _a.schema, depth = _a.depth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    var namedType = getNamedType(field.type);\n    var args = [];\n    var removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(function (arg) {\n            var argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    var fieldPath = __spreadArray(__spreadArray([], __read(path)), [field.name]);\n    var fieldPathStr = fieldPath.join('.');\n    var fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!isScalarType(namedType) && !isEnumType(namedType)) {\n        return __assign(__assign({ kind: Kind.FIELD, name: {\n                kind: Kind.NAME,\n                value: field.name,\n            } }, (fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } })), { selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models: models,\n                firstCall: firstCall,\n                path: fieldPath,\n                ancestors: __spreadArray(__spreadArray([], __read(ancestors)), [type]),\n                ignore: ignore,\n                depthLimit: depthLimit,\n                circularReferenceDepth: circularReferenceDepth,\n                schema: schema,\n                depth: depth + 1,\n                argNames: argNames,\n                selectedFields: selectedFields,\n            }) || undefined, arguments: args });\n    }\n    return __assign(__assign({ kind: Kind.FIELD, name: {\n            kind: Kind.NAME,\n            value: field.name,\n        } }, (fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } })), { arguments: args });\n}\nfunction hasCircularRef(types, config) {\n    if (config === void 0) { config = {\n        depth: 1,\n    }; }\n    var type = types[types.length - 1];\n    if (isScalarType(type)) {\n        return false;\n    }\n    var size = types.filter(function (t) { return t.name === type.name; }).length;\n    return size > config.depth;\n}\n//# sourceMappingURL=build-operation-for-field.js.map","export var VisitSchemaKind;\n(function (VisitSchemaKind) {\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind || (VisitSchemaKind = {}));\nexport var MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n//# sourceMappingURL=Interfaces.js.map","import { GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, isObjectType, isInterfaceType, isInputObjectType, Kind, GraphQLList, GraphQLNonNull, } from 'graphql';\nexport function createNamedStub(name, type) {\n    var constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name: name,\n        fields: {\n            _fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nexport function createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nexport function isNamedStub(type) {\n    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n        var fields = type.getFields();\n        var fieldNames = Object.keys(fields);\n        return fieldNames.length === 1 && fields[fieldNames[0]].name === '_fake';\n    }\n    return false;\n}\nexport function getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n//# sourceMappingURL=stub.js.map","import { __assign } from \"tslib\";\nimport { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLObjectType, GraphQLNonNull, GraphQLScalarType, GraphQLUnionType, isInterfaceType, isEnumType, isInputObjectType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isUnionType, isSpecifiedScalarType, isSpecifiedDirective, } from 'graphql';\nimport { getBuiltInForStub, isNamedStub } from './stub';\nexport function rewireTypes(originalTypeMap, directives) {\n    var referenceTypeMap = Object.create(null);\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    });\n    var newTypeMap = Object.create(null);\n    Object.keys(referenceTypeMap).forEach(function (typeName) {\n        var namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            return;\n        }\n        var newName = namedType.name;\n        if (newName.startsWith('__')) {\n            return;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(\"Duplicate schema type name \" + newName);\n        }\n        newTypeMap[newName] = namedType;\n    });\n    Object.keys(newTypeMap).forEach(function (typeName) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    });\n    var newDirectives = directives.map(function (directive) { return rewireDirective(directive); });\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        var directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        var rewiredArgs = {};\n        Object.keys(args).forEach(function (argName) {\n            var arg = args[argName];\n            var rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        });\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            var config_1 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            var config_2 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = function () {\n                    return rewireNamedTypes(config_2.interfaces);\n                };\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            var config_3 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            var config_4 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            var enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            var scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(\"Unexpected schema type: \" + type);\n    }\n    function rewireFields(fields) {\n        var rewiredFields = {};\n        Object.keys(fields).forEach(function (fieldName) {\n            var field = fields[fieldName];\n            var rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        var rewiredFields = {};\n        Object.keys(fields).forEach(function (fieldName) {\n            var field = fields[fieldName];\n            var rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        var rewiredTypes = [];\n        namedTypes.forEach(function (namedType) {\n            var rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        });\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            var rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            var rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            var rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=rewire.js.map","import { getNullableType, isLeafType, isListType, isInputObjectType } from 'graphql';\nexport function transformInputValue(type, value, inputLeafValueTransformer, inputObjectValueTransformer) {\n    if (inputLeafValueTransformer === void 0) { inputLeafValueTransformer = null; }\n    if (inputObjectValueTransformer === void 0) { inputObjectValueTransformer = null; }\n    if (value == null) {\n        return value;\n    }\n    var nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n    }\n    else if (isListType(nullableType)) {\n        return value.map(function (listMember) {\n            return transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer);\n        });\n    }\n    else if (isInputObjectType(nullableType)) {\n        var fields_1 = nullableType.getFields();\n        var newValue_1 = {};\n        Object.keys(value).forEach(function (key) {\n            var field = fields_1[key];\n            if (field != null) {\n                newValue_1[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        });\n        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue_1) : newValue_1;\n    }\n    // unreachable, no other possible return value\n}\nexport function serializeInputValue(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });\n}\nexport function parseInputValue(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });\n}\nexport function parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.parseLiteral(v, {}); });\n}\n//# sourceMappingURL=transformInputValue.js.map","import { __assign, __read, __spreadArray } from \"tslib\";\nimport { GraphQLObjectType, GraphQLSchema, isInterfaceType, isEnumType, isObjectType, isScalarType, isUnionType, isInputObjectType, GraphQLInputObjectType, GraphQLInterfaceType, isLeafType, isListType, isNonNullType, isNamedType, GraphQLList, GraphQLNonNull, GraphQLEnumType, Kind, } from 'graphql';\nimport { MapperKind, } from './Interfaces';\nimport { rewireTypes } from './rewire';\nimport { serializeInputValue, parseInputValue } from './transformInputValue';\nexport function mapSchema(schema, schemaMapper) {\n    if (schemaMapper === void 0) { schemaMapper = {}; }\n    var originalTypeMap = schema.getTypeMap();\n    var newTypeMap = mapDefaultValues(originalTypeMap, schema, serializeInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, function (type) { return isLeafType(type); });\n    newTypeMap = mapEnumValues(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapDefaultValues(newTypeMap, schema, parseInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, function (type) { return !isLeafType(type); });\n    newTypeMap = mapFields(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapArguments(newTypeMap, schema, schemaMapper);\n    var originalDirectives = schema.getDirectives();\n    var newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    var queryType = schema.getQueryType();\n    var mutationType = schema.getMutationType();\n    var subscriptionType = schema.getSubscriptionType();\n    var newQueryTypeName = queryType != null ? (newTypeMap[queryType.name] != null ? newTypeMap[queryType.name].name : undefined) : undefined;\n    var newMutationTypeName = mutationType != null\n        ? newTypeMap[mutationType.name] != null\n            ? newTypeMap[mutationType.name].name\n            : undefined\n        : undefined;\n    var newSubscriptionTypeName = subscriptionType != null\n        ? newTypeMap[subscriptionType.name] != null\n            ? newTypeMap[subscriptionType.name].name\n            : undefined\n        : undefined;\n    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;\n    return new GraphQLSchema(__assign(__assign({}, schema.toConfig()), { query: newQueryTypeName ? typeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName ? typeMap[newMutationTypeName] : undefined, subscription: newSubscriptionTypeName != null ? typeMap[newSubscriptionTypeName] : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn) {\n    if (testFn === void 0) { testFn = function () { return true; }; }\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    });\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    var _a;\n    var enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, (_a = {},\n        _a[MapperKind.ENUM_TYPE] = function (type) {\n            var config = type.toConfig();\n            var originalEnumValueConfigMap = config.values;\n            var newEnumValueConfigMap = {};\n            Object.keys(originalEnumValueConfigMap).forEach(function (externalValue) {\n                var originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                var mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    var _a = __read(mappedEnumValue, 2), newExternalValue = _a[0], newEnumValueConfig = _a[1];\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            });\n            return correctASTNodes(new GraphQLEnumType(__assign(__assign({}, config), { values: newEnumValueConfigMap })));\n        },\n        _a), function (type) { return isEnumType(type); });\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    var _a, _b;\n    var newTypeMap = mapArguments(originalTypeMap, schema, (_a = {},\n        _a[MapperKind.ARGUMENT] = function (argumentConfig) {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            var maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return __assign(__assign({}, argumentConfig), { defaultValue: fn(maybeNewType, argumentConfig.defaultValue) });\n            }\n        },\n        _a));\n    return mapFields(newTypeMap, schema, (_b = {},\n        _b[MapperKind.INPUT_OBJECT_FIELD] = function (inputFieldConfig) {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            var maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return __assign(__assign({}, inputFieldConfig), { defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue) });\n            }\n        },\n        _b));\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        var newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        var newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        var newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var fieldMapper_1 = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper_1 == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var config = originalType.toConfig();\n            var originalFieldConfigMap_1 = config.fields;\n            var newFieldConfigMap_1 = {};\n            Object.keys(originalFieldConfigMap_1).forEach(function (fieldName) {\n                var originalFieldConfig = originalFieldConfigMap_1[fieldName];\n                var mappedField = fieldMapper_1(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap_1[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    var _a = __read(mappedField, 2), newFieldName = _a[0], newFieldConfig = _a[1];\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = __assign(__assign({}, newFieldConfig.astNode), { name: __assign(__assign({}, newFieldConfig.astNode.name), { value: newFieldName }) });\n                    }\n                    newFieldConfigMap_1[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap_1[fieldName] = mappedField;\n                }\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var argumentMapper_1 = getArgumentMapper(schemaMapper);\n            if (argumentMapper_1 == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var config = originalType.toConfig();\n            var originalFieldConfigMap_2 = config.fields;\n            var newFieldConfigMap_2 = {};\n            Object.keys(originalFieldConfigMap_2).forEach(function (fieldName) {\n                var originalFieldConfig = originalFieldConfigMap_2[fieldName];\n                var originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap_2[fieldName] = originalFieldConfig;\n                    return;\n                }\n                var argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap_2[fieldName] = originalFieldConfig;\n                    return;\n                }\n                var newArgumentConfigMap = {};\n                argumentNames.forEach(function (argumentName) {\n                    var originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    var mappedArgument = argumentMapper_1(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        var _a = __read(mappedArgument, 2), newArgumentName = _a[0], newArgumentConfig = _a[1];\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                });\n                newFieldConfigMap_2[fieldName] = __assign(__assign({}, originalFieldConfig), { args: newArgumentConfigMap });\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    var directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    var newDirectives = [];\n    originalDirectives.forEach(function (directive) {\n        var mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    });\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var type = schema.getType(typeName);\n    var specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    var specifiers = getTypeSpecifiers(schema, typeName);\n    var typeMapper;\n    var stack = __spreadArray([], __read(specifiers));\n    while (!typeMapper && stack.length > 0) {\n        var next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var type = schema.getType(typeName);\n    var specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    var specifiers = getFieldSpecifiers(schema, typeName);\n    var fieldMapper;\n    var stack = __spreadArray([], __read(specifiers));\n    while (!fieldMapper && stack.length > 0) {\n        var next = stack.pop();\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper != null ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    var argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    var enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nexport function correctASTNodes(type) {\n    if (isObjectType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_1 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_1.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.OBJECT_TYPE_DEFINITION, fields: fields_1 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.OBJECT_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_2 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_2.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.INTERFACE_TYPE_DEFINITION, fields: fields_2 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.INTERFACE_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_3 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_3.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.INPUT_OBJECT_TYPE_DEFINITION, fields: fields_3 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.INPUT_OBJECT_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var values_1 = [];\n            Object.values(config.values).forEach(function (enumValueConfig) {\n                if (enumValueConfig.astNode != null) {\n                    values_1.push(enumValueConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { values: values_1 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { values: undefined })); });\n        }\n        return new GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n//# sourceMappingURL=mapSchema.js.map","import { __read, __values } from \"tslib\";\nimport { GraphQLInputObjectType, GraphQLInterfaceType, GraphQLObjectType, } from 'graphql';\nimport { MapperKind } from './Interfaces';\nimport { mapSchema } from './mapSchema';\nexport function filterSchema(_a) {\n    var _b;\n    var schema = _a.schema, _c = _a.typeFilter, typeFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.fieldFilter, fieldFilter = _d === void 0 ? undefined : _d, _e = _a.rootFieldFilter, rootFieldFilter = _e === void 0 ? undefined : _e, _f = _a.objectFieldFilter, objectFieldFilter = _f === void 0 ? undefined : _f, _g = _a.interfaceFieldFilter, interfaceFieldFilter = _g === void 0 ? undefined : _g, _h = _a.inputObjectFieldFilter, inputObjectFieldFilter = _h === void 0 ? undefined : _h, _j = _a.argumentFilter, argumentFilter = _j === void 0 ? undefined : _j;\n    var filteredSchema = mapSchema(schema, (_b = {},\n        _b[MapperKind.QUERY] = function (type) { return filterRootFields(type, 'Query', rootFieldFilter, argumentFilter); },\n        _b[MapperKind.MUTATION] = function (type) {\n            return filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter);\n        },\n        _b[MapperKind.SUBSCRIPTION] = function (type) {\n            return filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter);\n        },\n        _b[MapperKind.OBJECT_TYPE] = function (type) {\n            return typeFilter(type.name, type)\n                ? filterE